//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// Tue Jul 30 2019 21:10:21
//
//      Input file      : 
//      Component name  : lsadrgen
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------

//**************************************************************************************************** 
// Address generator for Load/Store instructions 
// Designed by Ruslan Lepetenok 
// Modified 15.12.2002 
//**************************************************************************************************** 

module lsadrgen(
   nRESET,
   CLK,
   CLKEN,
   RmDataIn,
   BDataOut,
   RegisterList,
   IncBeforeSel,
   DecBeforeSel,
   DecAfterSel,
   MltAdrSel,
   SngMltSel
);
   // Global control signals 
   input         nRESET;
   input         CLK;
   input         CLKEN;
   // Control and data 
   input [31:0]  RmDataIn;
   output [31:0] BDataOut;
   reg [31:0]    BDataOut;
   input [15:0]  RegisterList;
   input         IncBeforeSel;		// May be used for branches for LR correction !!! 
   input         DecBeforeSel;
   input         DecAfterSel;
   input         MltAdrSel;		// 0 -> Start address, 1-> Base reg. update (only for LDM/STM) 
   input         SngMltSel;		// 0 -> LDM/STM, 1 -> LDR/STR 
   
   reg [31:0]    RegListToOffsetConv[0:15];
   wire [31:0]   OffsetForMlt;
   reg [31:0]    BaseRegUpdOffset;
   wire [31:0]   MltSngMux;
   wire [31:0]   OffsetUpdateMux;
   
   always @(*) RegListToOffsetConv[0] <= (RegisterList[0] == 1'b1) ? 32'h00000004 : 
                                         //{(15-31:0][0)+1{1'b0}};	// X-HDL
										 32'h00000000;
   
   generate
      begin : xhdl0
         genvar        i;
         for (i = 1; i <= 15; i = i + 1)
         begin : ConverterLogic
            always @(*) RegListToOffsetConv[i] <= (RegisterList[i] == 1'b1) ? RegListToOffsetConv[i - 1] + 4 : 
                                                  RegListToOffsetConv[i - 1];
         end
      end
   endgenerate
   
   assign OffsetForMlt = (IncBeforeSel == 1'b1) ? 32'h00000004 : 		// Have the highest priority (for LR correction during branches) 
                         (DecBeforeSel == 1'b1) ? RegListToOffsetConv[15] : 
                         (DecAfterSel == 1'b1) ? RegListToOffsetConv[15] - 4 : 
                         {32{1'b0}};		// Increment after 
   
   assign OffsetUpdateMux = (MltAdrSel == 1'b0) ? OffsetForMlt : 		// Start address for LDM/STM 
                            BaseRegUpdOffset;		// Base register update for LDM/STM 
   
   
   always @(negedge nRESET or posedge CLK)
   begin: AdrOffsetRegs
      if (nRESET == 1'b0)		// Reset 
         BaseRegUpdOffset <= {32{1'b0}};
      else 		// Clock 
      begin
         if (CLKEN == 1'b1)		// Clock enable 
            BaseRegUpdOffset <= RegListToOffsetConv[15];
      end
   end
   
   
   always @(negedge nRESET or posedge CLK)
   begin: OutputReg
      if (nRESET == 1'b0)		// Reset 
         BDataOut <= {32{1'b0}};
      else 		// Clock 
      begin
         if (CLKEN == 1'b1)		// Clock enable 
            BDataOut <= MltSngMux;
      end
   end
   
   assign MltSngMux = (SngMltSel == 1'b1) ? RmDataIn : 		// LDR/STR (the second cycle - base update) 
                      OffsetUpdateMux;		// LDM/STM and LR update ?? 		            
   
endmodule

