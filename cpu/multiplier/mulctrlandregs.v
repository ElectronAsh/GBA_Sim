//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// Tue Jul 30 2019 21:12:16
//
//      Input file      : 
//      Component name  : mulctrlandregs
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------

//**************************************************************************************************** 
// Multiplier control and Partial Sum/Carry registers for ARM core 
// Designed by Ruslan Lepetenok 
// Modified 12.02.2003 
//**************************************************************************************************** 

module mulctrlandregs(
   nRESET,
   CLK,
   CLKEN,
   Rs9Out,
   PartialSumOut,
   PartialCarryOut,
   PartialSumIn,
   PartialCarryIn,
   PP4P,
   PP4M,
   ADataIn,
   BDataIn,
   LoadRsRm,
   LoadPS,
   ClearPSC,
   UnsignedMul,
   ReadLH,
   MulResRdy,
   ResPartSum,
   ResPartCarry
);
   parameter     EarlyTermination = 0;
   // Global signals 
   input         nRESET;
   input         CLK;
   input         CLKEN;
   // Interface for the 32x8 combinatorial multiplier  
   output [8:0]  Rs9Out;
   output [63:0] PartialSumOut;
   output [63:0] PartialCarryOut;
   input [63:0]  PartialSumIn;
   input [63:0]  PartialCarryIn;
   output        PP4P;
   output        PP4M;
   // Data inputs 
   input [31:0]  ADataIn;		// RdHi(Rn)/Rs data path  
   input [31:0]  BDataIn;		// RdLo(Rd)/Rm data path 
   // Control inputs 
   input         LoadRsRm;		// Load Rs and Rm and start 
   input         LoadPS;		// Load partial sum register with RHi:RLo    
   input         ClearPSC;		// Clear prtial sum and carry register 
   input         UnsignedMul;		// Unsigned multiplication 
   input         ReadLH;		// 0 - Read PS/PC low,1 - Read PS/PC high 
   // Control outputs 
   output        MulResRdy;		// Multiplication result is ready 
   // Result 
   output [31:0] ResPartSum;
   output [31:0] ResPartCarry;
   
   
   // Partial sum and partial carry registers signals 
   reg [63:0]    PartialSumReg;
   wire [63:0]   PartialSumRegIn;
   reg [63:0]    PartialCarryReg;
   wire [63:0]   PartialCarryRegIn;
   
   wire [63:0]   PartialSumMasked;
   wire [63:0]   PartialCarryMasked;
   
   wire [63:0]   PartialSumRealing;
   wire [63:0]   PartialCarryRealing;
   
   // Control state machine 
   reg           nMulSt0;
   reg           MulSt1;
   reg           MulSt2;
   reg           MulSt3;
   reg           MulSt4;
   
   // Early termination signals 
   wire          EarlyTerm1C;		// Early termination after the first cycle 
   wire          EarlyTerm2C;		// Early termination after the second cycle 
   wire          EarlyTerm3C;		// Early termination after the third cycle 
   
   reg           MulResRdyInt;
   
   // Realignment circuit 
   reg [1:0]     RealignCnt;
   wire [1:0]    RealignCntIn;
   
   reg           UMulLastCycle;
   
   assign Rs9Out = (LoadRsRm == 1'b1) ? {ADataIn[7:0], 1'b0} : 		// First cycle of the multiplication  
                   (MulSt1 == 1'b1) ? ADataIn[15:7] : 		// Second cycle of the multiplication  
                   (MulSt2 == 1'b1) ? ADataIn[23:15] : 		// Third cycle of the multiplication  
                   (MulSt3 == 1'b1) ? ADataIn[31:23] : 		// Forth cycle of the multiplication  
                   {9{CDnCr}};
   
   
   always @(negedge nRESET or posedge CLK)
   begin: MainControlSm
      if (nRESET == 1'b0)		// Reset 
      begin
         nMulSt0 <= 1'b0;
         MulSt1 <= 1'b0;
         MulSt2 <= 1'b0;
         MulSt3 <= 1'b0;
         MulSt4 <= 1'b0;
         MulResRdyInt <= 1'b0;
         UMulLastCycle <= 1'b0;
      end
      
      else 		// Clock 
      begin
         if (CLKEN == 1'b1)		// Clock enable 
         begin
            nMulSt0 <= ((~nMulSt0) & LoadRsRm & (~EarlyTerm1C)) | (nMulSt0 & (~((MulSt1 & EarlyTerm2C) | (MulSt2 & EarlyTerm3C) | MulSt3)));
            
            MulSt1 <= (~MulSt1) & (~nMulSt0) & LoadRsRm & (~EarlyTerm1C);
            MulSt2 <= (~MulSt2) & MulSt1 & (~EarlyTerm2C);
            MulSt3 <= (~MulSt3) & MulSt2 & (~EarlyTerm3C);
            MulResRdyInt <= ((~MulResRdyInt) & ((LoadRsRm & EarlyTerm1C) | (MulSt1 & EarlyTerm2C) | (MulSt2 & EarlyTerm3C) | MulSt3)) | (MulResRdyInt & (~ClearPSC));		// Clear ready flag after multiplication 
            
            UMulLastCycle <= (~MulSt3) & MulSt2 & (~EarlyTerm3C) & UnsignedMul & ADataIn[31];		// The last cycle of unsigned multiplication and Rs[31]='1' -> +X 
         end
      end
   end
   
   assign MulResRdy = MulResRdyInt;
   
   // +X 
   assign PP4P = ((nMulSt0 == 1'b0 & EarlyTerm1C == 1'b1 & ADataIn[8:7] == 2'b01) | (MulSt1 == 1'b1 & EarlyTerm2C == 1'b1 & ADataIn[16:15] == 2'b01) | (MulSt2 == 1'b1 & EarlyTerm3C == 1'b1 & ADataIn[24:23] == 2'b01) | UMulLastCycle == 1'b1) ? 1'b1 : 
                 1'b0;
   
   // -X					   
   assign PP4M = ((nMulSt0 == 1'b0 & EarlyTerm1C == 1'b1 & ADataIn[8:7] == 2'b10) | (MulSt1 == 1'b1 & EarlyTerm2C == 1'b1 & ADataIn[16:15] == 2'b10) | (MulSt2 == 1'b1 & EarlyTerm3C == 1'b1 & ADataIn[24:23] == 2'b10)) ? 1'b1 : 
                 1'b0;
   
   // Early termination conditions 
   // Cycle                              1               2                3          
   // Signed multiplication        [31:8]='0'/'1'	[31:16]='0'/'1'	 [31:24]='0'/'1' 
   // Unsigned multiplication      [31:8]='0'	    [31:16]='0' 	 [31:24]='0' 
   
   // Early termination logic 
   assign EarlyTerm1C = (((UnsignedMul == 1'b1 & ADataIn[31:8] == 25'b0000000000000000000000000) | (UnsignedMul == 1'b0 & (ADataIn[31:8] == 25'b0000000000000000000000000 | ADataIn[31:8] == 25'b1111111111111111111111111))) & EarlyTermination) ? 1'b1 : 
                        1'b0;
   
   assign EarlyTerm2C = (((UnsignedMul == 1'b1 & ADataIn[31:16] == 17'b00000000000000000) | (UnsignedMul == 1'b0 & (ADataIn[31:16] == 17'b00000000000000000 | ADataIn[31:16] == 17'b11111111111111111))) & EarlyTermination) ? 1'b1 : 
                        1'b0;
   
   assign EarlyTerm3C = (((UnsignedMul == 1'b1 & ADataIn[31:24] == 9'b000000000) | (UnsignedMul == 1'b0 & (ADataIn[31:24] == 9'b000000000 | ADataIn[31:24] == 9'b111111111))) & EarlyTermination) ? 1'b1 : 
                        1'b0;
   
   
   always @(negedge nRESET or posedge CLK)
   begin: RealignmentCounter
      if (nRESET == 1'b0)		// Reset 
         RealignCnt <= {2{1'b0}};
      else 		// Clock 
      begin
         if ((LoadRsRm | nMulSt0) == 1'b1 & CLKEN == 1'b1)		// Clock enable 
            RealignCnt <= RealignCntIn;
      end
   end
   
   assign RealignCntIn = (LoadRsRm == 1'b1) ? {2{1'b0}} : 
                         RealignCnt + 1;
   
   // Partial sum and partial carry registers 
   
   always @(negedge nRESET or posedge CLK)
   begin: PartialSum_Load_Rotate
      if (nRESET == 1'b0)		// Reset 
         PartialSumReg <= {64{1'b0}};
      else 		// Clock 
      begin
         if ((LoadPS | LoadRsRm | nMulSt0 | ClearPSC) == 1'b1 & CLKEN == 1'b1)		// Clock enable 
            PartialSumReg <= PartialSumRegIn;
      end
   end
   
   
   always @(negedge nRESET or posedge CLK)
   begin: PartialCarry_Clear_Rotate
      if (nRESET == 1'b0)		// Reset 
         PartialCarryReg <= {64{1'b0}};
      else 		// Clock 
      begin
         if ((LoadRsRm | nMulSt0 | ClearPSC) == 1'b1 & CLKEN == 1'b1)		// Clock enable 
            PartialCarryReg <= PartialCarryRegIn;
      end
   end
   
   assign PartialSumRegIn = (ClearPSC == 1'b1) ? {64{1'b0}} : 		// Clear (after multiplication) 
                            (LoadPS == 1'b1) ? {ADataIn, BDataIn} : 		// Load (for accumulation) 
                            PartialSumMasked;		// Rotate  
   
   assign PartialSumMasked = (LoadRsRm == 1'b1) ? {PartialSumIn[7:0], PartialSumIn[63:8]} : 
                             (MulSt1 == 1'b1) ? {PartialSumIn[7:0], PartialSumReg[63:56], PartialSumIn[55:8]} : 
                             (MulSt2 == 1'b1) ? {PartialSumIn[7:0], PartialSumReg[63:48], PartialSumIn[47:8]} : 
                             (MulSt3 == 1'b1) ? {PartialSumIn[7:0], PartialSumReg[63:40], PartialSumIn[39:8]} : 
                             {64{CDnCr}};
   
   assign PartialCarryRegIn = (ClearPSC == 1'b1) ? {64{1'b0}} : 		// Clear (after multiplication) 
                              PartialCarryMasked;		// Rotate  
   
   assign PartialCarryMasked = (LoadRsRm == 1'b1) ? {PartialCarryIn[7:0], PartialCarryIn[63:8]} : 
                               (MulSt1 == 1'b1) ? {PartialCarryIn[7:0], PartialCarryReg[63:56], PartialCarryIn[55:8]} : 
                               (MulSt2 == 1'b1) ? {PartialCarryIn[7:0], PartialCarryReg[63:48], PartialCarryIn[47:8]} : 
                               (MulSt3 == 1'b1) ? {PartialCarryIn[7:0], PartialCarryReg[63:40], PartialCarryIn[39:8]} : 
                               {64{CDnCr}};
   
   assign PartialSumOut = PartialSumReg;
   assign PartialCarryOut = PartialCarryReg;
   
   // Result : partial sum and partial carry (64 bits) 
   assign PartialSumRealing = (RealignCnt == 2'b00) ? {PartialSumReg[55:0], PartialSumReg[63:56]} : 		// Terminated after the second cycle ?? 
                              (RealignCnt == 2'b01) ? {PartialSumReg[47:0], PartialSumReg[63:48]} : 		// Terminated after the second cycle ?? 
                              (RealignCnt == 2'b10) ? {PartialSumReg[39:0], PartialSumReg[63:40]} : 		// Terminated after the third cycle ?? 
                              (RealignCnt == 2'b11) ? {PartialSumReg[31:0], PartialSumReg[63:32]} : 
                              {64{CDnCr}};
   
   assign PartialCarryRealing = (RealignCnt == 2'b00) ? {PartialCarryReg[55:0], PartialCarryReg[63:56]} : 		// Terminated after the second cycle ?? 
                                (RealignCnt == 2'b01) ? {PartialCarryReg[47:0], PartialCarryReg[63:48]} : 		// Terminated after the second cycle ?? 
                                (RealignCnt == 2'b10) ? {PartialCarryReg[39:0], PartialCarryReg[63:40]} : 		// Terminated after the third cycle	?? 
                                (RealignCnt == 2'b11) ? {PartialCarryReg[31:0], PartialCarryReg[63:32]} : 
                                {64{CDnCr}};
   
   assign ResPartSum = (ReadLH == 1'b1) ? PartialSumRealing[63:32] : 
                       PartialSumRealing[31:0];
   
   // Shift left partial carry by 1  
   assign ResPartCarry = (ReadLH == 1'b1) ? PartialCarryRealing[62:31] : 
                         {PartialCarryRealing[30:0], 1'b0};
   
endmodule
