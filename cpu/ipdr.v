//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// Tue Jul 30 2019 21:10:17
//
//      Input file      : 
//      Component name  : ipdr
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------

//****************************************************************************************************
// Instruction pipeline register, data in register  for ARM7TDMI-S processor
// Designed by Ruslan Lepetenok
// Modified 23.01.2003
//****************************************************************************************************

module ipdr(
   nRESET,
   CLK,
   CLKEN,
   RDATA,
   ABORT,
   ToThumbDecoder,
   FromThumbDecoder,
   HalfWordAddress,
   InstForDecode,
   InstFetchAbort,
   ADDRLow,
   StagnatePipeline,
   StagnatePipelineDel,
   FirstInstFetch,
   DataOut,
   SignExt,
   ZeroExt,
   nB_HW,
   SExtOffset24Bit,
   Offset12Bit,
   Offset8Bit,
   Immediate8Bit,
   EndianMode
);
   `include "armpackage.v"
   // Clock and reset
   input         nRESET;
   input         CLK;
   input         CLKEN;
   // Memory interface
   input [31:0]  RDATA;
   input         ABORT;
   // Thumb decoder interface
   output [31:0] ToThumbDecoder;
   reg [31:0]    ToThumbDecoder;
   input [31:0]  FromThumbDecoder;
   output        HalfWordAddress;
   reg           HalfWordAddress;
   // Interfaces for the internal CPU modules
   output [31:0] InstForDecode;
   output        InstFetchAbort;
   reg           InstFetchAbort;
   input [1:0]   ADDRLow;		// Address [1..0]
   input         StagnatePipeline;
   input         StagnatePipelineDel;
   input         FirstInstFetch;
   // Data out register and control(sign/zero, byte/halfword  extension)
   output [31:0] DataOut;
   input         SignExt;
   input         ZeroExt;
   input         nB_HW;
   // Immediate fields out
   output [31:0] SExtOffset24Bit;
   reg [31:0]    SExtOffset24Bit;
   output [31:0] Offset12Bit;
   reg [31:0]    Offset12Bit;
   output [31:0] Offset8Bit;
   reg [31:0]    Offset8Bit;
   output [31:0] Immediate8Bit;
   reg [31:0]    Immediate8Bit;
   // Bus control
   input         EndianMode;
   
   
   // Endian converter
   wire [31:0]   EndianConverterOut;
   
   // Data rotator
   wire [31:0]   DataRotator;
   
   // Set of signals for prefetch
   reg [31:0]    PrefetchedInstruction;
   reg           PrefetchedAbort;
   reg           PrefetchedHWAdr;		// Address of halfword (ADDR[1])
   
   // Set of signals for fetch
   wire [31:0]   FetchedInstructionIn;
   
   wire          FetchedAbortIn;
   wire [1:0]    FetchADDRLow;
   wire          FetchedHWAdrIn;		// HWAdrIn for FETCH instruction
   
   // Sign or zero extension signals
   reg [31:0]    DataReg;
   wire [31:0]   ByteExtended;
   wire [31:0]   HalfWordExtended;
   
   // Big endian to little endian convertion ??
   assign EndianConverterOut = (EndianMode == 1'b0) ? RDATA : 		// Little endian mode
                               {RDATA[7:0], RDATA[15:8], RDATA[23:16], RDATA[31:24]};		// Big endian mode
   
   
   always @(negedge nRESET or posedge CLK)
   begin: Prefetch
      if (nRESET == 1'b0)		// Reset
      begin
         PrefetchedInstruction <= {32{1'b0}};
         PrefetchedAbort <= 1'b0;
         PrefetchedHWAdr <= 1'b0;
      end
      else 		// Clock
      begin
         if (StagnatePipelineDel == 1'b0 & StagnatePipeline == 1'b1 & CLKEN == 1'b1)		// Clock enable
         begin
            PrefetchedInstruction <= EndianConverterOut;
            PrefetchedAbort <= ABORT;
            PrefetchedHWAdr <= ADDRLow[1];		// TBD might need to be FetchedADDRLow
         end
      end
   end
   
   assign FetchedInstructionIn = (StagnatePipelineDel == 1'b1 & StagnatePipeline == 1'b0) ? PrefetchedInstruction : 
                                 EndianConverterOut;
   
   assign FetchedAbortIn = (StagnatePipelineDel == 1'b1 & StagnatePipeline == 1'b0) ? PrefetchedAbort : 
                           ABORT;
   
   assign FetchedHWAdrIn = (StagnatePipelineDel == 1'b1 & StagnatePipeline == 1'b0) ? PrefetchedHWAdr : 
                           ADDRLow[1];
   
   
   always @(negedge nRESET or posedge CLK)
   begin: Fetch
      if (nRESET == 1'b0)		// Reset
      begin
         ToThumbDecoder <= {32{1'b0}};
         InstFetchAbort <= 1'b0;
         HalfWordAddress <= 1'b0;
      end
      else 		// Clock
      begin
         if (StagnatePipeline == 1'b0 & FirstInstFetch == 1'b1 & CLKEN == 1'b1)		// Clock enable
         begin
            ToThumbDecoder <= FetchedInstructionIn;
            InstFetchAbort <= FetchedAbortIn;
            HalfWordAddress <= FetchedHWAdrIn;
         end
      end
   end
   
   assign InstForDecode = FromThumbDecoder;
   
   
   always @(negedge nRESET or posedge CLK)
   begin: ImmediateDataRegs
      if (nRESET == 1'b0)		// Reset
      begin
         SExtOffset24Bit <= {32{1'b0}};
         Offset12Bit <= {32{1'b0}};
         Offset8Bit <= {32{1'b0}};
         Immediate8Bit <= {32{1'b0}};
      end
      else 		// Clock
      begin
         if (StagnatePipeline == 1'b0 & CLKEN == 1'b1)		// Clock enable
         begin
            SExtOffset24Bit <= {FromThumbDecoder[23], FromThumbDecoder[23:0]};
            Offset12Bit <= {1'b0, FromThumbDecoder[11:0]};
            Offset8Bit <= {1'b0, FromThumbDecoder[11:8], FromThumbDecoder[3:0]};
            Immediate8Bit <= {1'b0, FromThumbDecoder[7:0]};
         end
      end
   end
   
   // Data in register
   
   always @(negedge nRESET or posedge CLK)
   begin: DataInReg
      if (nRESET == 1'b0)		// Reset
         DataReg <= {32{1'b0}};
      else 		// Clock
      begin
         if (CLKEN == 1'b1)		// Clock enable
            DataReg <= DataRotator;		// Data fetched from memory
      end
   end
   
   // Data rotator
   assign DataRotator = (ADDRLow == 2'b00) ? EndianConverterOut : 
                        (ADDRLow == 2'b01) ? {EndianConverterOut[7:0], EndianConverterOut[31:8]} : 
                        (ADDRLow == 2'b10) ? {EndianConverterOut[15:0], EndianConverterOut[31:16]} : 
                        (ADDRLow == 2'b11) ? {EndianConverterOut[23:0], EndianConverterOut[31:24]} : 
                        {32{CDnCr}};
   
   assign ByteExtended = (SignExt == 1'b0) ? {1'b0, DataReg[7:0]} : 
                         {DataReg[7], DataReg[7:0]};
   
   assign HalfWordExtended = (SignExt == 1'b0) ? {1'b0, DataReg[15:0]} : 
                             {DataReg[15], DataReg[15:0]};
   
   assign DataOut = (SignExt == 1'b0 & ZeroExt == 1'b0) ? DataReg : 
                    (nB_HW == 1'b0) ? ByteExtended : 
                    (nB_HW == 1'b1) ? HalfWordExtended : 
                    {32{CDnCr}};
   
endmodule
`undef ARMPackage
