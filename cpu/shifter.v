//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// Tue Jul 30 2019 21:10:51
//
//      Input file      : 
//      Component name  : shifter
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------

//**************************************************************************************************** 
// Shifter for ARM core 
// Designed by Ruslan Lepetenok 
// Modified 23.01.2003 
//**************************************************************************************************** 

module shifter(
   ShBBusIn,
   ShOut,
   ShCFlagIn,
   ShCFlagOut,
   ShLenRs,
   ShLenImm,
   ShType,
   ShRotImm,
   ShEn,
   ShCFlagEn
);
   `include "armpackage.v"
   input [31:0]  ShBBusIn;		// Input data (B-Bus) 
   output [31:0] ShOut;		// Output data 
   input         ShCFlagIn;		// Input of the carry flag  
   output        ShCFlagOut;		// Output of the carry flag  
   input [7:0]   ShLenRs;		// Shift amount for register shift (value of Rs[7..0])  
   input [4:0]   ShLenImm;		// Shift amount for immediate shift (bits [11..7]) 
   input [2:0]   ShType;		// Shift type (bits 6,5 and 4 of instruction) 
   input         ShRotImm;		// Rotate immediate 8-bit value 
   input         ShEn;
   input         ShCFlagEn;
   
   // ******************************************************************************************** 
   // Operation priority: 0 -> ShRotImm  
   //					   1 -> others types of shift 
   // 
   //  ShType[0]  
   //         0 -> immediate shift 
   //		   1 ->	register shift	(takes additional cycle) 
   // 
   //  ShType[2..1] 
   //           00 -> LSL   
   //           01	-> LSR 
   //			 10	-> ASR 
   //			 11	-> ROR/RRX(when ShType[0]='0' and ShLen[4..0]="00000") 
   // 
   // 
   // ******************************************************************************************** 
   
   
   reg [31:0]    LeftShifter[31:0];
   reg [31:0]    RightShifter[31:0];
   reg [31:0]    LeftShifterMUX[31:0];
   reg [31:0]    RightShifterMUX[31:0];
   wire [4:0]    LeftShifterLen;
   wire [4:0]    RightShifterLen;
   wire [31:0]   VacatedBitsR;		// Vacated bits for right shift 
   wire          RightShiftLenLSB;
   
   wire [31:0]   RightCarryMUX;
   wire [31:0]   LeftCarryMUX;
   
   wire [31:0]   ShOutInt;
   wire          ShCFlagOutInt;
   
   assign RightShiftLenLSB = (ShRotImm == 1'b1) ? 1'b0 : 		// Rotate 8-bit immediate 
                             ShLenImm[0];
   
   assign LeftShifterLen = (ShType[0] == 1'b0) ? ShLenImm : 		//  Left immediate shift 
                           ShLenRs[4:0];		//  Left register shift 
   
   assign RightShifterLen = (ShType[0] == 1'b0 | ShRotImm == 1'b1) ? {ShLenImm[4:0 + 1], RightShiftLenLSB} : 		//  Right immediate shift 
                            ShLenRs[4:0];		//  Right register shift 
   
   always @(*) RightShifter[0] <= (ShRotImm == 1'b1) ? {24'b000000000000000000000000, ShBBusIn[7:0]} : 		// Rotate 8-bit immediate 
                                  ShBBusIn;
   
   always @(*) LeftShifter[0] <= ShBBusIn;
   always @(*) LeftShifterMUX[0] <= LeftShifter[0];
   always @(*) RightShifterMUX[0] <= RightShifter[0];
   
   assign LeftCarryMUX[0] = ShCFlagIn;
   assign RightCarryMUX[0] = ShCFlagIn;
   
   generate
      begin : xhdl0
         genvar        i;
         for (i = 1; i <= 31; i = i + 1)
         begin : ShifterLogic
            // Left shift logic 
            always @(*) LeftShifter[i] <= {LeftShifter[i - 1][30:0], 1'b0};
            
            // Right shift logic 
            always @(*) RightShifter[i] <= {VacatedBitsR[i], RightShifter[i - 1][31:1]};
            
            assign VacatedBitsR[i] = (ShType[2:1] == 2'b11 | ShRotImm == 1'b1) ? RightShifter[i - 1][0] : 		// Rotate right ROR 
                                     (ShType[2:1] == 2'b10) ? ShBBusIn[31] : 		// Arithmetical shift right (MSB) ASR 
                                     (ShType[2] == 1'b0) ? 1'b0 : 		// Logical shift right LSR 
                                     CDnCr;
            
            // Left shift output MUX				    
            always @(*) LeftShifterMUX[i] <= (i == LeftShifterLen) ? LeftShifter[i] : 		// LSL 
                                             LeftShifterMUX[i - 1];
            
            // Right shift output MUX				   					  
            always @(*) RightShifterMUX[i] <= (i == RightShifterLen) ? RightShifter[i] : 
                                              RightShifterMUX[i - 1];
            
            // Carry bit logic 
            assign LeftCarryMUX[i] = (i == LeftShifterLen) ? LeftShifter[i - 1][31] : 		// Rm[32-shift_imm]/Rm[32-Rs[7:0]] 
                                     LeftCarryMUX[i - 1];
            
            assign RightCarryMUX[i] = (i == RightShifterLen) ? RightShifter[i - 1][0] : 		// Rm[shift_imm-1]/Rm[Rs[7:0]-1] 
                                      RightCarryMUX[i - 1];
         end
      end
   endgenerate
   
   assign ShOutInt = (ShRotImm == 1'b1) ? RightShifterMUX[31] : 		// Immediate rotate 
   // (LSL(R) + LSR(R)) & Rm[7:0]>31 
                     (((ShType == 3'b001 | ShType == 3'b011) & ShLenRs[7:5] != 3'b000) | (ShType == 3'b010 & ShLenImm == 5'b00000)) ? {32{1'b0}} : 		// LSR(I) & shift_imm==0            
   // ASR(I) & shift_imm==0)+(ASR(R) & Rs[7:0]>31 
                     ((ShType == 3'b100 & ShLenImm == 5'b00000) | (ShType == 3'b101 & ShLenRs[7:5] != 3'b000)) ? {32{ShBBusIn[31]}} : 		// ASR(R) & Rs[7:0]>31 
                     (ShType == 3'b110 & ShLenImm == 5'b00000) ? ({ShCFlagIn, ShBBusIn[31:1]}) : 		// RRX             
                     ((ShType[2] | ShType[1]) == 1'b1) ? RightShifterMUX[31] : 		// LSR/ASR/ROR 
                     (ShType[2:1] == 2'b00) ? LeftShifterMUX[31] : 		// LSL 
                     {32{CDnCr}};
   
   // Output of C Flag 
   assign ShCFlagOutInt = (ShRotImm == 1'b1 & ShLenImm[4:1] == 4'b0000) ? RightCarryMUX[31] : 		// Immediate rotate and rotate_imm==0 
                          (ShRotImm == 1'b1 & ShLenImm[4:1] != 4'b0000) ? ShOutInt[31] : 		// Immediate rotate and rotate_imm!=0		 
                          ((ShType == 3'b001 & ShLenRs == 32) | (ShType == 3'b110 & ShLenRs == 8'h00)) ? ShBBusIn[0] : 		// (LSL(R) & Rs[7:0]==32)+(ROR(I)&shift_&imm==0) 
   // (LSR(I)+ASR(I))&shift_imm==0 
   // ASR(R)&Rs[7:0]>=32 
                          (((ShType == 3'b010 | ShType == 3'b100) & ShLenImm == 5'b00000) | (ShType == 3'b101 & ShLenRs[7:5] != 3'b000) | (ShType == 3'b111 & ShLenRs[7:5] != 3'b000 & ShLenRs[4:0] == 5'b00000)) ? ShBBusIn[31] : 		// ROR(R)&Rs[7:5]!=0&Rs[4:0]==0 
                          ((ShType == 3'b001 | ShType == 3'b011) & ShLenRs > 32) ? 1'b0 : 		// (LSL(R) + LSR(R)) & Rs[7:0]>32                      
                          ((ShType[2] | ShType[1]) == 1'b1) ? RightCarryMUX[31] : 		// LSR/ASR/ROR 
                          (ShType[2:1] == 2'b00) ? LeftCarryMUX[31] : 		// LSL 
                          CDnCr;
   
   assign ShOut = (ShEn == 1'b1) ? ShOutInt : 
                  ShBBusIn;
   assign ShCFlagOut = (ShCFlagEn == 1'b1) ? ShCFlagOutInt : 
                       ShCFlagIn;
   
endmodule
`undef ARMPackage
