//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// Tue Jul 30 2019 21:10:34
//
//      Input file      : 
//      Component name  : regfile
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------

//****************************************************************************************************
// Register file for ARM core
// Designed by Ruslan Lepetenok
// Modified 23.01.2003
//****************************************************************************************************

module regfile(		// Debug mode flag
   nRESET,
   CLK,
   CLKEN,
   ABusOut,
   BBusOut,
   DataIn,
   ABusRdAdr,
   BBusRdAdr,
   WriteAdr,
   WrEn,
   PCIn,
   PCOut,
   PCWrEn,
   PCSrcSel,
   RFMode,
   SaveBaseReg,
   RestoreBaseReg
);
   `include "armpackage.v"
   parameter     DebugMode = 1'b1;
   
   // Global control signals
   input         nRESET;
   input         CLK;
   input         CLKEN;
   // Data buses
   output [31:0] ABusOut;
   output [31:0] BBusOut;
   input [31:0]  DataIn;
   // Address an control
   input [3:0]   ABusRdAdr;
   input [3:0]   BBusRdAdr;
   input [3:0]   WriteAdr;
   input         WrEn;
   // Program counter
   input [31:0]  PCIn;
   output [31:0] PCOut;
   input         PCWrEn;		//???
   input         PCSrcSel;
   // Global control
   input [4:0]   RFMode;
   input         SaveBaseReg;
   input         RestoreBaseReg;
   
   
   // User mode registers r0-r15
   reg [31:0]    UMRegisterFile[0:15];
   
   // FIQ mode registers r8-r14
   reg [31:0]    FIQMRegisterFile[8:14];
   
   // Other modes registers r13,r14
   reg [31:0]    SVCMRegisterFile[13:14];	// SVC
   reg [31:0]    AMRegisterFile[13:14];		// Abort
   reg [31:0]    IRQMRegisterFile[13:14];	// IRQ
   reg [31:0]    UndMRegisterFile[13:14];	// Undefined
   
   `define PC UMRegisterFile[15]
   wire [31:0]   PCSrc;
   
   reg [31:0]    ABusOutMUX[0:15];
   reg [31:0]    BBusOutMUX[0:15];
   
   //signal RegFileOut : UMRegisterFileType $ (others => x"0000_0000");
   
   reg [31:0]    RegFileAOut[0:15];
   reg [31:0]    RegFileBOut[0:15];
   
   // Modes
   wire          UserMode;
   wire          FIQMode;
   wire          IRQMode;
   wire          SVCMode;
   wire          AbortMode;
   wire          UndefMode;
   
   reg [31:0]    SavedBaseReg;
   wire [31:0]   RegsIn;
   wire [31:0]   lr;
   wire [31:0]   sp;
   wire [31:0]   r0;
   wire [31:0]   r1;
   wire [31:0]   r2;
   wire [31:0]   r3;
   wire [31:0]   r4;
   wire [31:0]   r5;
   wire [31:0]   r6;
   wire [31:0]   r7;
   wire [31:0]   r8;
   wire [31:0]   r9;
   wire [31:0]   r10;
   wire [31:0]   r11;
   wire [31:0]   r12;
   
   // Individual write enable signals
   //signal IndWrEn : std_logic_vector(15 downto 0) $ (others => '0');
   
   assign lr = UMRegisterFile[14];
   assign sp = UMRegisterFile[13];
   assign r0 = UMRegisterFile[0];
   assign r1 = UMRegisterFile[1];
   assign r2 = UMRegisterFile[2];
   assign r3 = UMRegisterFile[3];
   assign r4 = UMRegisterFile[4];
   assign r5 = UMRegisterFile[5];
   assign r6 = UMRegisterFile[6];
   assign r7 = UMRegisterFile[7];
   assign r8 = UMRegisterFile[8];
   assign r9 = UMRegisterFile[9];
   assign r10 = UMRegisterFile[10];
   assign r11 = UMRegisterFile[11];
   assign r12 = UMRegisterFile[12];
   
   //IndWriteEnLogic:for i in IndWrEn'range generate
   // IndWrEn(i)	<= '1' when i=WriteAdr else '0';
   //end generate;
   
   // Mode decode logic
   assign UserMode = (RFMode == CUserMode | RFMode == CSystemMode) ? 1'b1 : 
                     1'b0;
   assign FIQMode = (RFMode == CFIQMode) ? 1'b1 : 
                    1'b0;
   assign IRQMode = (RFMode == CIRQMode) ? 1'b1 : 
                    1'b0;
   assign SVCMode = (RFMode == CSVCMode) ? 1'b1 : 
                    1'b0;
   assign AbortMode = (RFMode == CAbortMode) ? 1'b1 : 
                      1'b0;
   assign UndefMode = (RFMode == CUndefMode) ? 1'b1 : 
                      1'b0;
   
   assign RegsIn = (RestoreBaseReg == 1'b1) ? SavedBaseReg : 
                   DataIn;
   
   
   always @(negedge nRESET or posedge CLK)
   begin: BaseRegister
      if (nRESET == 1'b0)		// Reset
         SavedBaseReg <= {32{1'b0}};
      else 		// Clock
      begin
         if (SaveBaseReg == 1'b1 & CLKEN == 1'b1)		// Clock enable
            SavedBaseReg <= ABusOutMUX[15];
      end
   end
   
   
   always @(negedge nRESET or posedge CLK)
   begin: LowAndUMHighRegs
      integer       i;
      if (nRESET == 1'b0)		// Reset
      begin
         if (DebugMode)
         begin
            for (i = 0; i <= 15 - 1; i = i + 1)		// was '-1'
               //UMRegisterFile[i] <= { (15-31:0][0)+ 1{1'b0} };	// X-HDL.
			   UMRegisterFile[i] <= 32'h00000000;
            `PC <= CPCInitVal;
         end
      end
      else 		// Clock
      begin
         // User Mode registers r0-r7
         for (i = 0; i <= 7; i = i + 1)
            if (WrEn == 1'b1 & i == WriteAdr & CLKEN == 1'b1)		// Clock enable
               UMRegisterFile[i] <= RegsIn;
         
         // User Mode registers r8-r12(banked)
         for (i = 8; i <= 12; i = i + 1)
            if (WrEn == 1'b1 & i == WriteAdr & FIQMode == 1'b0 & CLKEN == 1'b1)		// Clock enable
               UMRegisterFile[i] <= RegsIn;
         
         // User Mode registers r13-r14(banked)
         for (i = 8; i <= 15 - 1; i = i + 1)
            if (WrEn == 1'b1 & i == WriteAdr & UserMode == 1'b1 & CLKEN == 1'b1)		// Clock enable
               UMRegisterFile[i] <= RegsIn;
         
         // Program counter (r15)
         if (((WrEn == 1'b1 & WriteAdr == 4'b1111) | PCWrEn == 1'b1) & CLKEN == 1'b1)		// Clock enable
            `PC <= {PCSrc[31:1], 1'b0};
      end
   end
   
   // Program counter logic
   assign PCSrc = (PCSrcSel == 1'b0) ? PCIn : 
                  DataIn;
   assign PCOut = `PC;
   
   // r8-r14 FIQ Mode
   always @(negedge nRESET or posedge CLK)
   begin: FIQModeHighRegs
      integer       i;
      if (nRESET == 1'b0)		// Reset
      begin
         if (DebugMode)
            for (i = 8; i <= 14; i = i + 1)
               //FIQMRegisterFile[i] <= {(14-31:0][8)+1{1'b0}};		// X-HDL
			   FIQMRegisterFile[i] <= 32'h00000000;
      end
      else 		// Clock
         for (i = 8; i <= 14; i = i + 1)
            if (WrEn == 1'b1 & i == WriteAdr & FIQMode == 1'b1 & CLKEN == 1'b1)		// Clock enable
               FIQMRegisterFile[i] <= RegsIn;
   end
   
   // r13-r14 SVC Mode
   always @(negedge nRESET or posedge CLK)
   begin: SVCModeHighRegs
      integer       i;
      if (nRESET == 1'b0)		// Reset
      begin
         if (DebugMode)
            for (i = 13; i <= 14; i = i + 1)
               //SVCMRegisterFile[i] <= {(14-31:0][13)+1{1'b0}};	// X-HDL
			   SVCMRegisterFile[i] <= 32'h00000000;
      end
      else 		// Clock
         for (i = 13; i <= 14; i = i + 1)
            if (WrEn == 1'b1 & i == WriteAdr & SVCMode == 1'b1 & CLKEN == 1'b1)		// Clock enable
               SVCMRegisterFile[i] <= RegsIn;
   end
   
   // r13-r14 Abort Mode
   always @(negedge nRESET or posedge CLK)
   begin: AbortModeHighRegs
      integer       i;
      if (nRESET == 1'b0)		// Reset
      begin
         if (DebugMode)
            for (i = 13; i <= 14; i = i + 1)
               //AMRegisterFile[i] <= {(14-31:0][13)+1{1'b0}};	// X-HDL
			   AMRegisterFile[i] <= 32'h00000000;
      end
      else 		// Clock
         for (i = 13; i <= 14; i = i + 1)
            if (WrEn == 1'b1 & i == WriteAdr & AbortMode == 1'b1 & CLKEN == 1'b1)		// Clock enable
               AMRegisterFile[i] <= RegsIn;
   end
   
   // r13-r14 IRQ Mode
   always @(negedge nRESET or posedge CLK)
   begin: IRQModeHighRegs
      integer       i;
      if (nRESET == 1'b0)		// Reset
      begin
         if (DebugMode)
            for (i = 13; i <= 14; i = i + 1)
               //IRQMRegisterFile[i] <= {(14-31:0][13)+1{1'b0}};	// X-HDL
			   IRQMRegisterFile[i] <= 32'h00000000;
      end
      else 		// Clock
         for (i = 13; i <= 14; i = i + 1)
            if (WrEn == 1'b1 & i == WriteAdr & IRQMode == 1'b1 & CLKEN == 1'b1)		// Clock enable
               IRQMRegisterFile[i] <= RegsIn;
   end
   
   // r13-r14 Undefined Mode
   always @(negedge nRESET or posedge CLK)
   begin: UndefModeHighRegs
      integer       i;
      if (nRESET == 1'b0)		// Reset
      begin
         if (DebugMode)
            for (i = 13; i <= 14; i = i + 1)
               //UndMRegisterFile[i] <= {(14-31:0][13)+1{1'b0}};	// X-HDL
			   UndMRegisterFile[i] <= 32'h00000000;
      end
      else 		// Clock
         for (i = 13; i <= 14; i = i + 1)
            if (WrEn == 1'b1 & i == WriteAdr & UndefMode == 1'b1 & CLKEN == 1'b1)		// Clock enable
               UndMRegisterFile[i] <= RegsIn;
   end
   
   // Output multiplexers
   
   // Non banked registers (R0-R7)
   generate
      begin : xhdl0
         genvar        i;
         for (i = 0; i <= 7; i = i + 1)
         begin : RegistersOutputsLow
            always @(*) RegFileAOut[i] <= UMRegisterFile[i];
            always @(*) RegFileBOut[i] <= UMRegisterFile[i];
         end
      end
   endgenerate
   
   // R8-R12
   generate
      begin : xhdl1
         genvar        i;
         for (i = 8; i <= 12; i = i + 1)
         begin : RegistersOutputs
            always @(*) RegFileAOut[i] <= (FIQMode == 1'b0) ? UMRegisterFile[i] : 
                                          FIQMRegisterFile[i];
            
            always @(*) RegFileBOut[i] <= (FIQMode == 1'b0) ? UMRegisterFile[i] : 
                                          FIQMRegisterFile[i];
         end
      end
   endgenerate
   
   // R13-R14
   generate
      begin : xhdl2
         genvar        i;
         for (i = 13; i <= 14; i = i + 1)
         begin : RegistersOutputsHigh
            always @(*) RegFileAOut[i] <= (UserMode == 1'b1) ? UMRegisterFile[i] : 
                                          (FIQMode == 1'b1) ? FIQMRegisterFile[i] : 
                                          (SVCMode == 1'b1) ? SVCMRegisterFile[i] : 
                                          (AbortMode == 1'b1) ? AMRegisterFile[i] : 
                                          (IRQMode == 1'b1) ? IRQMRegisterFile[i] : 
                                          (UndefMode == 1'b1) ? UndMRegisterFile[i] : 
                                          //{(15-31:0][0)+1{CDnCr}};	// X-HDL
										  32'h00000000;		// This is a "don't care" value, declared in ARMPackage.vhd as...
															// constant CDnCr : std_logic := '0';
            
            always @(*) RegFileBOut[i] <= (UserMode == 1'b1) ? UMRegisterFile[i] : 
                                          (FIQMode == 1'b1) ? FIQMRegisterFile[i] : 
                                          (SVCMode == 1'b1) ? SVCMRegisterFile[i] : 
                                          (AbortMode == 1'b1) ? AMRegisterFile[i] : 
                                          (IRQMode == 1'b1) ? IRQMRegisterFile[i] : 
                                          (UndefMode == 1'b1) ? UndMRegisterFile[i] : 
                                          //{(15-31:0][0)+1{CDnCr}};	// X-HDl
										  32'h00000000;		// This is a "don't care" value, declared in ARMPackage.vhd as...
															// constant CDnCr : std_logic := '0';
         end
      end
   endgenerate
   
   //R15
   always @(*) RegFileAOut[15] <= `PC;
   always @(*) RegFileBOut[15] <= `PC;
   
   always @(*) ABusOutMUX[0] <= RegFileAOut[0];
   always @(*) BBusOutMUX[0] <= RegFileBOut[0];
   generate
      begin : xhdl3
         genvar        i;
         for (i = 1; i <= 15; i = i + 1)
         begin : OutputDataMUX
            always @(*) ABusOutMUX[i] <= (i == ABusRdAdr) ? RegFileAOut[i] : 
                                         ABusOutMUX[i - 1];
            always @(*) BBusOutMUX[i] <= (i == BBusRdAdr) ? RegFileBOut[i] : 
                                         BBusOutMUX[i - 1];
         end
      end
   endgenerate
   
   assign ABusOut = ABusOutMUX[15];
   assign BBusOut = BBusOutMUX[15];
   
endmodule
`undef ARMPackage

